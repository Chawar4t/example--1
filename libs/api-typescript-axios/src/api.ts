/* tslint:disable */
/* eslint-disable */
/**
 * FlowAccount Business API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BatchHistory
 */
export interface BatchHistory {
    /**
     * 
     * @type {Array<BatchImportMetadata>}
     * @memberof BatchHistory
     */
    'metadataList'?: Array<BatchImportMetadata> | null;
}
/**
 * 
 * @export
 * @interface BatchImportMetadata
 */
export interface BatchImportMetadata {
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'companyUserGuid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'templateId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    'filename'?: string | null;
    /**
     * 
     * @type {DocumentTypes}
     * @memberof BatchImportMetadata
     */
    'documentType'?: DocumentTypes;
    /**
     * 
     * @type {BatchImportStatus}
     * @memberof BatchImportMetadata
     */
    'status'?: BatchImportStatus;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'documentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'failedCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchImportMetadata
     */
    's3Key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatchImportMetadata
     */
    'companyId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BatchImportMetadata
     */
    'isViewed'?: boolean;
}
/**
 * 
 * @export
 * @interface BatchImportPayload
 */
export interface BatchImportPayload {
    /**
     * 
     * @type {Array<SimpleDocument>}
     * @memberof BatchImportPayload
     */
    'simpleDocuments'?: Array<SimpleDocument> | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportPayload
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchImportPayload
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchImportPayload
     */
    'batchCount'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BatchImportStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type BatchImportStatus = typeof BatchImportStatus[keyof typeof BatchImportStatus];


/**
 * 
 * @export
 * @interface BatchMessageSent
 */
export interface BatchMessageSent {
    /**
     * 
     * @type {string}
     * @memberof BatchMessageSent
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BatchMessageSent
     */
    'documentCount'?: number;
}
/**
 * 
 * @export
 * @interface BatchMessageStatus
 */
export interface BatchMessageStatus {
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'companyUserGuid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'batchId'?: string | null;
    /**
     * 
     * @type {BatchImportStatus}
     * @memberof BatchMessageStatus
     */
    'status'?: BatchImportStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'messageId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'failedReason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMessageStatus
     */
    'payload'?: string | null;
}
/**
 * 
 * @export
 * @interface BatchStatus
 */
export interface BatchStatus {
    /**
     * 
     * @type {Array<BatchMessageStatus>}
     * @memberof BatchStatus
     */
    'messages'?: Array<BatchMessageStatus> | null;
    /**
     * 
     * @type {BatchImportMetadata}
     * @memberof BatchStatus
     */
    'metadata'?: BatchImportMetadata | null;
}
/**
 * 
 * @export
 * @interface DateFormatType
 */
export interface DateFormatType {
    /**
     * 
     * @type {string}
     * @memberof DateFormatType
     */
    'format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DateFormatType
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeductionType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type DeductionType = typeof DeductionType[keyof typeof DeductionType];


/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'saleAndPurchaseChannel'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentTypes = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_21: 21,
    NUMBER_23: 23,
    NUMBER_24: 24,
    NUMBER_25: 25,
    NUMBER_29: 29,
    NUMBER_31: 31,
    NUMBER_33: 33,
    NUMBER_35: 35,
    NUMBER_51: 51,
    NUMBER_53: 53,
    NUMBER_55: 55,
    NUMBER_57: 57,
    NUMBER_59: 59,
    NUMBER_61: 61,
    NUMBER_63: 63,
    NUMBER_65: 65,
    NUMBER_67: 67,
    NUMBER_69: 69,
    NUMBER_71: 71,
    NUMBER_73: 73,
    NUMBER_151: 151,
    NUMBER_153: 153,
    NUMBER_155: 155,
    NUMBER_157: 157,
    NUMBER_159: 159,
    NUMBER_201: 201,
    NUMBER_202: 202,
    NUMBER_203: 203,
    NUMBER_204: 204
} as const;

export type DocumentTypes = typeof DocumentTypes[keyof typeof DocumentTypes];


/**
 * 
 * @export
 * @enum {string}
 */

export const Entity = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15
} as const;

export type Entity = typeof Entity[keyof typeof Entity];


/**
 * 
 * @export
 * @enum {string}
 */

export const IncomeType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_15: 15,
    NUMBER_17: 17,
    NUMBER_19: 19,
    NUMBER_21: 21,
    NUMBER_23: 23,
    NUMBER_25: 25,
    NUMBER_27: 27,
    NUMBER_29: 29
} as const;

export type IncomeType = typeof IncomeType[keyof typeof IncomeType];


/**
 * 
 * @export
 * @interface InlineDocument
 */
export interface InlineDocument {
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineDocument
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'discountType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocument
     */
    'useInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'exemptAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocument
     */
    'vatableAmount'?: number | null;
    /**
     * 
     * @type {Array<InlineProductItem>}
     * @memberof InlineDocument
     */
    'items'?: Array<InlineProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof InlineDocument
     */
    'documentReference'?: Array<UpgradeDocument> | null;
}
/**
 * 
 * @export
 * @interface InlineDocumentAllOf
 */
export interface InlineDocumentAllOf {
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'discountType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocumentAllOf
     */
    'useInlineDiscount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineDocumentAllOf
     */
    'useInlineVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'exemptAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineDocumentAllOf
     */
    'vatableAmount'?: number | null;
    /**
     * 
     * @type {Array<InlineProductItem>}
     * @memberof InlineDocumentAllOf
     */
    'items'?: Array<InlineProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof InlineDocumentAllOf
     */
    'documentReference'?: Array<UpgradeDocument> | null;
}
/**
 * 
 * @export
 * @interface InlineProductItem
 */
export interface InlineProductItem {
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineProductItem
     */
    'vatRate'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentMethod = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_9: 9,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_51: 51
} as const;

export type PaymentMethod = typeof PaymentMethod[keyof typeof PaymentMethod];


/**
 * 
 * @export
 * @interface PaymentModel
 */
export interface PaymentModel {
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'cashRemarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'excludeVat'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'cashTax'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'creditCardNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'companyVatRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'net'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'bankAccountNumber'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'bankAccountId'?: number | null;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentModel
     */
    'paymentMethod'?: PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'dateNow'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'amountCollected'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'amountWithheld'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'withholdingTax'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'transferBankAccountId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'bankAccountCreditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'charge'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeBankAccountId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'creditCardBankAccountId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'remainingCollected'?: number | null;
    /**
     * 
     * @type {RemainingCollectedType}
     * @memberof PaymentModel
     */
    'remainingCollectedType'?: RemainingCollectedType | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'deductionAmount'?: number | null;
    /**
     * 
     * @type {DeductionType}
     * @memberof PaymentModel
     */
    'paymentDeductionType'?: DeductionType | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'pettyCashName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'pettyCashId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'chequeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'creditCardId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'otherChannelId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeDepositDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'chequeDepositBankId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'chequeCashingDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentModel
     */
    'autoCreateWithholdingTax'?: boolean;
    /**
     * 
     * @type {IncomeType}
     * @memberof PaymentModel
     */
    'withholdingTaxIncomeType'?: IncomeType;
    /**
     * 
     * @type {string}
     * @memberof PaymentModel
     */
    'withholdingTaxIncomeDescription'?: string | null;
    /**
     * 
     * @type {Entity}
     * @memberof PaymentModel
     */
    'withholdingTaxEntity'?: Entity;
    /**
     * 
     * @type {number}
     * @memberof PaymentModel
     */
    'exchangeRateFee'?: number | null;
}
/**
 * 
 * @export
 * @interface PreSignUploadSimpleDocumentPayload
 */
export interface PreSignUploadSimpleDocumentPayload {
    /**
     * 
     * @type {string}
     * @memberof PreSignUploadSimpleDocumentPayload
     */
    'fileName'?: string | null;
}
/**
 * 
 * @export
 * @interface PreSignUploadSimpleDocumentResponse
 */
export interface PreSignUploadSimpleDocumentResponse {
    /**
     * 
     * @type {string}
     * @memberof PreSignUploadSimpleDocumentResponse
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreSignUploadSimpleDocumentResponse
     */
    'batchId'?: string;
}
/**
 * 
 * @export
 * @interface ProductItem
 */
export interface ProductItem {
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductItem
     */
    'productCode'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RemainingCollectedType = {
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_51: 51,
    NUMBER_53: 53,
    NUMBER_55: 55,
    NUMBER_57: 57
} as const;

export type RemainingCollectedType = typeof RemainingCollectedType[keyof typeof RemainingCollectedType];


/**
 * 
 * @export
 * @interface SimpleDocument
 */
export interface SimpleDocument {
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactTaxId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactBranch'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactPerson'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'contactZipCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'contactGroup'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'publishedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'creditType'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'creditDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'salesName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'projectName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'reference'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'isVatInclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'useReceiptDeduction'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'subTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'discountAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'totalAfterDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'isVat'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'vatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'documentShowWithholdingTax'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentWithholdingTaxPercentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentWithholdingTaxAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentDeductionType'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'documentDeductionAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'remarks'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'internalNotes'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleDocument
     */
    'showSignatureOrStamp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'documentStructureType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleDocument
     */
    'saleAndPurchaseChannel'?: string | null;
    /**
     * 
     * @type {Array<SimpleProductItem>}
     * @memberof SimpleDocument
     */
    'items'?: Array<SimpleProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof SimpleDocument
     */
    'documentReference'?: Array<UpgradeDocument> | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocument
     */
    'exemptAmount'?: number | null;
}
/**
 * 
 * @export
 * @interface SimpleDocumentAllOf
 */
export interface SimpleDocumentAllOf {
    /**
     * 
     * @type {Array<SimpleProductItem>}
     * @memberof SimpleDocumentAllOf
     */
    'items'?: Array<SimpleProductItem> | null;
    /**
     * 
     * @type {Array<UpgradeDocument>}
     * @memberof SimpleDocumentAllOf
     */
    'documentReference'?: Array<UpgradeDocument> | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleDocumentAllOf
     */
    'exemptAmount'?: number | null;
}
/**
 * 
 * @export
 * @interface SimpleProductItem
 */
export interface SimpleProductItem {
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'type'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'unitName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'pricePerUnit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimpleProductItem
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'sellChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'buyChartOfAccountCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimpleProductItem
     */
    'productCode'?: string | null;
}
/**
 * 
 * @export
 * @interface SpreadsheetTemplate
 */
export interface SpreadsheetTemplate {
    /**
     * 
     * @type {Array<SpreadsheetTemplateMetadata>}
     * @memberof SpreadsheetTemplate
     */
    'metadataList'?: Array<SpreadsheetTemplateMetadata> | null;
}
/**
 * 
 * @export
 * @interface SpreadsheetTemplateMetadata
 */
export interface SpreadsheetTemplateMetadata {
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetTemplateMetadata
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetTemplateMetadata
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetTemplateMetadata
     */
    'sheetIndex'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetTemplateMetadata
     */
    'columns'?: string | null;
    /**
     * 
     * @type {DateFormatType}
     * @memberof SpreadsheetTemplateMetadata
     */
    'dateFormat'?: DateFormatType;
    /**
     * 
     * @type {boolean}
     * @memberof SpreadsheetTemplateMetadata
     */
    'ignoreLastRow'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetTemplateMetadata
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetTemplateMetadata
     */
    'formulas'?: string | null;
}
/**
 * 
 * @export
 * @interface UpgradeDocument
 */
export interface UpgradeDocument {
    /**
     * 
     * @type {number}
     * @memberof UpgradeDocument
     */
    'recordId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpgradeDocument
     */
    'referenceDocumentSerial'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpgradeDocument
     */
    'referenceDocumentType'?: number;
}

/**
 * CashInvoiceApi - axios parameter creator
 * @export
 */
export const CashInvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceActorCreateCashInvoice: async (culture: string, batchImportPayload: BatchImportPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceActorCreateCashInvoice', 'culture', culture)
            // verify required parameter 'batchImportPayload' is not null or undefined
            assertParamExists('cashInvoiceActorCreateCashInvoice', 'batchImportPayload', batchImportPayload)
            const localVarPath = `/openapi/{culture}/cash-invoices/simple-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchImportPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {Array<InlineDocument>} inlineDocument 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceActorCreateCashInvoiceInline: async (culture: string, inlineDocument: Array<InlineDocument>, batchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceActorCreateCashInvoiceInline', 'culture', culture)
            // verify required parameter 'inlineDocument' is not null or undefined
            assertParamExists('cashInvoiceActorCreateCashInvoiceInline', 'inlineDocument', inlineDocument)
            const localVarPath = `/openapi/{culture}/cash-invoices/inline-document`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceChangeStatusByKey: async (documentId: number, statusKey: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'documentId', documentId)
            // verify required parameter 'statusKey' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'statusKey', statusKey)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceChangeStatusByKey', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/{documentId}/status-key/{statusKey}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"statusKey"}}`, encodeURIComponent(String(statusKey)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDetails: async (id: number, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceDetails', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceDetails', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGenerateBacthIdMetadata: async (culture: string, fileName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceGenerateBacthIdMetadata', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/batch-metadata`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGetCustomTemplates: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceGetCustomTemplates', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/custom-template`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGetOriginalFile: async (batchId: string, culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('cashInvoiceGetOriginalFile', 'batchId', batchId)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceGetOriginalFile', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/get-batch-import-org-file/{batchId}`
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceIndex: async (culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceIndex', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['CurrentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (filter !== undefined) {
                localVarQueryParameter['Filter'] = filter;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['SearchString'] = searchString;
            }

            if (customDocumentModels !== undefined) {
                localVarQueryParameter['CustomDocumentModels'] = customDocumentModels;
            }

            if (range !== undefined) {
                localVarQueryParameter['Range'] = range;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['StartDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['EndDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceMarkViewed: async (culture: string, body: number, userId?: number, batchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceMarkViewed', 'culture', culture)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('cashInvoiceMarkViewed', 'body', body)
            const localVarPath = `/openapi/{culture}/cash-invoices/mark-viewed`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {PreSignUploadSimpleDocumentPayload} preSignUploadSimpleDocumentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoicePreSignUploadSimpleDocument: async (culture: string, preSignUploadSimpleDocumentPayload: PreSignUploadSimpleDocumentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoicePreSignUploadSimpleDocument', 'culture', culture)
            // verify required parameter 'preSignUploadSimpleDocumentPayload' is not null or undefined
            assertParamExists('cashInvoicePreSignUploadSimpleDocument', 'preSignUploadSimpleDocumentPayload', preSignUploadSimpleDocumentPayload)
            const localVarPath = `/openapi/{culture}/cash-invoices/get-presign-for-upload-simpledoc`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preSignUploadSimpleDocumentPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceQueryBatch: async (culture: string, body: string, status?: BatchImportStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceQueryBatch', 'culture', culture)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('cashInvoiceQueryBatch', 'body', body)
            const localVarPath = `/openapi/{culture}/cash-invoices/query-batch`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceQueryBatchHistory: async (culture: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceQueryBatchHistory', 'culture', culture)
            const localVarPath = `/openapi/{culture}/cash-invoices/batch-import-history`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceReceivePayment: async (id: number, culture: string, paymentModel: PaymentModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'id', id)
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'culture', culture)
            // verify required parameter 'paymentModel' is not null or undefined
            assertParamExists('cashInvoiceReceivePayment', 'paymentModel', paymentModel)
            const localVarPath = `/openapi/{culture}/cash-invoices/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [s3Key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceTriggerBatchFromS3: async (culture: string, body: number, userId?: number, s3Key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culture' is not null or undefined
            assertParamExists('cashInvoiceTriggerBatchFromS3', 'culture', culture)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('cashInvoiceTriggerBatchFromS3', 'body', body)
            const localVarPath = `/openapi/{culture}/cash-invoices/trigger-batch-from-s3`
                .replace(`{${"culture"}}`, encodeURIComponent(String(culture)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (s3Key !== undefined) {
                localVarQueryParameter['s3Key'] = s3Key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashInvoiceApi - functional programming interface
 * @export
 */
export const CashInvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashInvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceActorCreateCashInvoice(culture: string, batchImportPayload: BatchImportPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceActorCreateCashInvoice(culture, batchImportPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {Array<InlineDocument>} inlineDocument 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceActorCreateCashInvoiceInline(culture: string, inlineDocument: Array<InlineDocument>, batchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMessageSent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceActorCreateCashInvoiceInline(culture, inlineDocument, batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceDetails(id, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceGenerateBacthIdMetadata(culture: string, fileName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchImportMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceGenerateBacthIdMetadata(culture, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceGetCustomTemplates(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpreadsheetTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceGetCustomTemplates(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceGetOriginalFile(batchId: string, culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceGetOriginalFile(batchId, culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceMarkViewed(culture, body, userId, batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {PreSignUploadSimpleDocumentPayload} preSignUploadSimpleDocumentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoicePreSignUploadSimpleDocument(culture: string, preSignUploadSimpleDocumentPayload: PreSignUploadSimpleDocumentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreSignUploadSimpleDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoicePreSignUploadSimpleDocument(culture, preSignUploadSimpleDocumentPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceQueryBatch(culture, body, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceQueryBatchHistory(culture: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceQueryBatchHistory(culture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceReceivePayment(id, culture, paymentModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [s3Key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cashInvoiceTriggerBatchFromS3(culture: string, body: number, userId?: number, s3Key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cashInvoiceTriggerBatchFromS3(culture, body, userId, s3Key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CashInvoiceApi - factory interface
 * @export
 */
export const CashInvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashInvoiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} culture 
         * @param {BatchImportPayload} batchImportPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceActorCreateCashInvoice(culture: string, batchImportPayload: BatchImportPayload, options?: any): AxiosPromise<BatchMessageSent> {
            return localVarFp.cashInvoiceActorCreateCashInvoice(culture, batchImportPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {Array<InlineDocument>} inlineDocument 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceActorCreateCashInvoiceInline(culture: string, inlineDocument: Array<InlineDocument>, batchId?: string, options?: any): AxiosPromise<BatchMessageSent> {
            return localVarFp.cashInvoiceActorCreateCashInvoiceInline(culture, inlineDocument, batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} documentId 
         * @param {string} statusKey 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceDetails(id: number, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceDetails(id, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGenerateBacthIdMetadata(culture: string, fileName?: string, options?: any): AxiosPromise<BatchImportMetadata> {
            return localVarFp.cashInvoiceGenerateBacthIdMetadata(culture, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGetCustomTemplates(culture: string, options?: any): AxiosPromise<SpreadsheetTemplate> {
            return localVarFp.cashInvoiceGetCustomTemplates(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} batchId 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceGetOriginalFile(batchId: string, culture: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceGetOriginalFile(batchId, culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} [sortBy] 
         * @param {string} [currentPage] 
         * @param {string} [pageSize] 
         * @param {string} [filter] 
         * @param {string} [searchString] 
         * @param {string} [customDocumentModels] 
         * @param {string} [range] 
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [batchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.cashInvoiceMarkViewed(culture, body, userId, batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {PreSignUploadSimpleDocumentPayload} preSignUploadSimpleDocumentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoicePreSignUploadSimpleDocument(culture: string, preSignUploadSimpleDocumentPayload: PreSignUploadSimpleDocumentPayload, options?: any): AxiosPromise<PreSignUploadSimpleDocumentResponse> {
            return localVarFp.cashInvoicePreSignUploadSimpleDocument(culture, preSignUploadSimpleDocumentPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {string} body 
         * @param {BatchImportStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: any): AxiosPromise<BatchStatus> {
            return localVarFp.cashInvoiceQueryBatch(culture, body, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceQueryBatchHistory(culture: string, options?: any): AxiosPromise<BatchHistory> {
            return localVarFp.cashInvoiceQueryBatchHistory(culture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} culture 
         * @param {PaymentModel} paymentModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: any): AxiosPromise<any> {
            return localVarFp.cashInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} culture 
         * @param {number} body 
         * @param {number} [userId] 
         * @param {string} [s3Key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cashInvoiceTriggerBatchFromS3(culture: string, body: number, userId?: number, s3Key?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.cashInvoiceTriggerBatchFromS3(culture, body, userId, s3Key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashInvoiceApi - object-oriented interface
 * @export
 * @class CashInvoiceApi
 * @extends {BaseAPI}
 */
export class CashInvoiceApi extends BaseAPI {
    /**
     * 
     * @param {string} culture 
     * @param {BatchImportPayload} batchImportPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceActorCreateCashInvoice(culture: string, batchImportPayload: BatchImportPayload, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceActorCreateCashInvoice(culture, batchImportPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {Array<InlineDocument>} inlineDocument 
     * @param {string} [batchId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceActorCreateCashInvoiceInline(culture: string, inlineDocument: Array<InlineDocument>, batchId?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceActorCreateCashInvoiceInline(culture, inlineDocument, batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} documentId 
     * @param {string} statusKey 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceChangeStatusByKey(documentId: number, statusKey: string, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceChangeStatusByKey(documentId, statusKey, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceDetails(id: number, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceDetails(id, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceGenerateBacthIdMetadata(culture: string, fileName?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceGenerateBacthIdMetadata(culture, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceGetCustomTemplates(culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceGetCustomTemplates(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} batchId 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceGetOriginalFile(batchId: string, culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceGetOriginalFile(batchId, culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} [sortBy] 
     * @param {string} [currentPage] 
     * @param {string} [pageSize] 
     * @param {string} [filter] 
     * @param {string} [searchString] 
     * @param {string} [customDocumentModels] 
     * @param {string} [range] 
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceIndex(culture: string, sortBy?: string, currentPage?: string, pageSize?: string, filter?: string, searchString?: string, customDocumentModels?: string, range?: string, month?: string, year?: string, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceIndex(culture, sortBy, currentPage, pageSize, filter, searchString, customDocumentModels, range, month, year, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {number} body 
     * @param {number} [userId] 
     * @param {string} [batchId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceMarkViewed(culture: string, body: number, userId?: number, batchId?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceMarkViewed(culture, body, userId, batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {PreSignUploadSimpleDocumentPayload} preSignUploadSimpleDocumentPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoicePreSignUploadSimpleDocument(culture: string, preSignUploadSimpleDocumentPayload: PreSignUploadSimpleDocumentPayload, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoicePreSignUploadSimpleDocument(culture, preSignUploadSimpleDocumentPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {string} body 
     * @param {BatchImportStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceQueryBatch(culture: string, body: string, status?: BatchImportStatus, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceQueryBatch(culture, body, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceQueryBatchHistory(culture: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceQueryBatchHistory(culture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} culture 
     * @param {PaymentModel} paymentModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceReceivePayment(id: number, culture: string, paymentModel: PaymentModel, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceReceivePayment(id, culture, paymentModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} culture 
     * @param {number} body 
     * @param {number} [userId] 
     * @param {string} [s3Key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashInvoiceApi
     */
    public cashInvoiceTriggerBatchFromS3(culture: string, body: number, userId?: number, s3Key?: string, options?: AxiosRequestConfig) {
        return CashInvoiceApiFp(this.configuration).cashInvoiceTriggerBatchFromS3(culture, body, userId, s3Key, options).then((request) => request(this.axios, this.basePath));
    }
}


